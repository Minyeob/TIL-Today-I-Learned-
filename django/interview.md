# 면접대비 질문 정리

### Overloading과 Overriding의 차이
##### Overloading
하나의 클래스 내에서 같은 이름의 메서드 여러개를 가지면서 매개변수의 유형과 
개수가 다르도록 하는 기술을 말한다.
##### Overriding
상위 클래스가 가지고 있는 메서드를 하위 클래스가 재정의해서 사용하는것을 말한다.

즉 overloading은 하나의 클래스에서 하나의 method에 대하여 각기 다른 파라미터에 따라
정의를 달리 해줌으로 하나의 method로 여러가지 파라미터에 대해 대응할 수 있고 하나의
method로 여러가지 동작을 하게 해주는것을 말한다.
예를 들어 자판기에서 커피를 뽑기 위해 coin이라는 함수를 만들때, coin(), coin(int n),
coin(int n, int m)에 대한 method를 각각 정의해줘 여러 파라미터에 대해 대응하고
각 파라미터에 따른 함수의 동작을 달리하는 방법을 말한다,

반면에 overriding은 class를 상속할 때 상위 클래스에서 정의되어 있는 method를 
하위클래스에서 재정의 하여 상속받은 method에 대하여 상위 클래스에서 정의된
내용과 다른 동작을 하도록 만드는 방법을 말한다.
예를 들어 animal이라는 class에서 짖는 동작을 하는 roar()라는 동작이 정의되어있다고 하면
animal class를 상속하는 dog, cat, pig등의 클래스에 대하여 overriding을 이용하여
roar함수를 각각 정의하여 animal class를 상속한 각 동물들의 클래스에서 roar라는
method에 대하여 각각 다르게 짖는 동작을 하도록 만들 수 있다.


### 절차지향과 객체지향의 차이
##### 절차지향
프로시저(루틴, 하위프로그램, 서브루틴, 메서드, 함수) 호출의 개념을 바탕으로 하고 있는
 프로그래밍 패러다임을 말한다.

위에서부터 순차적으로 실행된다.

컴퓨터의 작업처리방식이 절차지향방식과 비슷하기 때문에 객체지향방식보다 빠른 처리가 가능하다.

함수(or 프로시저)가 중심이되고 데이터는 보조기능을 하는 언어이다.

대표적인 언어로 C언어가 존재한다.

##### 객체지향
각각의 독립된 단위인 객체를 모델링하고 프로그램을 객체들의 상호작용으로 서술한 방식의
프로그래밍 패러다임을 말한다.

객체는 기능을 하는 함수와 객체에서 사용되는 데이터를 하나의 집합으로 포함하여
구성된다.

객체지향의 가장 큰 특징 3가지는 추상화, 캡슐화, 상속, 다형성이 있다.

##### 객체지향의 장점
- 객체지향 프로그래밍은 코드의 재사용성이 높다.
- 코드의 변경이 용이
- 직관적인 코드분석
- 개발속도 향상
- 상속을 통한 장점 극대화


###### 추상화
공통의 속성이나 기능을 묶어 이름을 붙이는 것을 말한다
객체 지향적 관점에서 클래스를 정의하는 것을 바로 추상화라고 정의 내릴 수 있겠다.
좀 더 살펴보면 물고기, 사자, 토끼, 뱀이 있을 때 우리는 이것들을 각각의 객체라 하며 
이 객체들을 하나로 묶으려 할 때, 만약 동물 또는 생물이라는 어떤 추상적인 객체로 
크게 정의한다고 하자. 이때 동물 또는 생물이라고 묶는 것을 추상화라고 한다.

[객체기술사전]에 따르면, 추상화란 '중요하지 않거나, 주 관심 대상이 아닌 자세한 부분은 감추거나 무시하고, 
가장 중요하고, 근간이 되고, 다른 대상들과 구분될 수 있는 면만을 포함하고 있는 모델이며, 
공통점을 강조하기 위해 차이점을 제거한 결과물'이라고 정의하고 있다. 
실제로 객체의 속성과 행위 중에서 관심 대상이 아닌 부분은 드러낼 필요가 없는 것이 추상화이다.

###### 캡슐화
캡슐화는 객체의 데이터와 method를 하나로 묶고 구현 내용의 일부, 예를 들어 데이터를 외부에 은닉하여
데이터에 바로 접근하지 못하게 하고, 메소드를 통해서만 접근이 가능하도록 만드는 방식을
말한다.
캡슐화를 통하여 클래스 내부의 속성이나 오퍼레이션을 외부에 노출하지 않고 보호할 수 있다.

###### 상속
상속은 이미 작성된 클래스를 이어 받아 새로운 클래스를 생성하는 기법으로 기존 코드를 재활용하여
새로운 코드를 작성할 수 있어 효율적이다.

###### 다형성
다형성은 하나의 이름을 가진 method로 여러 상황에 대처할 수 있게 하는것을 말한다.
하나의 이름을 가진 함수에 대해 override나 파라미터의 변화에 따라 각각의 기능을 하도록
만들 수 있으며 다형성을 구현하는 가장 대표적인 방법은 Overloading과 Overriding이다.

### 제네릭
제네릭은 흔히 형식매개변수라고 말한다.
설명하면 사용자가 전달하는 "형식" 을 매개 변수로 사용하여 형식 내부에서 형식 매개 변수로 정의된(주로 단일 형식 매개 변수에서는 T를 사용)
형식을 교체하는 것이다

    class TestGenericClass<T> {
            public TestGenericClass(T value) {
                Value = value;
            }
            
            public T Value { get; set; }
        }
        class Program {
            public static void Main() {
                
                // Int32, String 그리고 Boolean 형식을 가진 제네릭 클래스 선언
                TestGenericClass<Int32>        intClass    = new TestGenericClass<Int32>(12345);
                TestGenericClass<String>    stringClass    = new TestGenericClass<String>("12345");
                TestGenericClass<Boolean>    boolClass    = new TestGenericClass<Boolean>(true);
    
일반적인 형태처럼 형식이 특정하게 지정하지 않고 위의 코드처럼 class를 형식매개변수로 
정의 하여 사용자의 입력한 변수의 형식에 따라 형식매개변수의 형식을 정의하는 방법을 Generic 이라고 한다.

### Call by value와 Call by reference의 차이점
##### Call by value
call by value는 값에 의한 호출로 다음 코드와 같다

    void func(int n)
    {
        n=20;
    }
    void main()
    {
        int n=10;
        func(n);
        printf("%d",n);
    }
    
위의 코드를 보면 메인함수에서 변수 n을 정의하고 n=10이라고 선언하였다.
그리고 변수 n을 인자로 func 함수를 호출하였다.
그러면 호출된 함수 func는 메인 함수에서 인자 값을 넘겨 받게 되는데(2번), 
이 때 func 함수는 메인 함수의 변수 n의 데이터(값) 만을 가져다가 메모리에 새로운 공간을 만들어 데이터(값)을 저장하게 된다. 
그리고 나서 func 함수는 n의 값을 20으로 수정하게 된다.
하지만 메인 함수의 변수 n과 func 함수의 변수 n은 메모리상 다른 위치에 상주해 있으므로 직접적인 연관이 없다. 
따라서 func 함수가 종료됨과 동시에 func 함수의 변수 n은 소멸하게 된다. 
따라서 메인 함수로 돌아와 출력되는 printf 의 값은 메인 함수의 변수 n값인 10이 출력되게 된다.
이처럼 변수의 값을 복사하여 함수를 호출하는 방식을 Call by value라고 한다.

##### Call by reference
call by reference는 메모리의 주소를 이용한 호출로 다음 코드와 같다

    void func(int *n)
    {
        *n=20;
    }
    void main()
    {
         int n=10;
         func(&n);
         printf("%d",n);
    }   
    
우선 위의 코드를 보면 Call by Value와 마찬가지로 변수 n을 정의하고 n=10이라고 선언하였다.
그리고 func함수를 사용할 때 인자로써 n변수의 주소값인 &n을 넘겨준다.
그리고 func 함수가 호출되는데 메인 함수로부터 받아오는 인자를 포인터로 받아왔으므로 
n의 주소 값 &n의 포인터 *n이 되었음을 알 수 있다. 
이를 통해 메인 함수의 변수 n과 func 함수의 변수 n이 같은 주소 값을 가지게 되었다는 것을 알 수 있다. 
이제 func 함수에서 n 값에 20을 입력했다. 
메인 함수의 변수 n과 func 함수의 변수 n은 같은 변수가 맞으므로 메모리 상의 n의 값이 변경된다. 
따라서 func 함수 종료 후 메인 함수의 printf 실행 시 출력 값은 20이 된다.
이처럼 변수의 주소를 이용하여 함수를 호출하고 변수의 포인터를 이용하여 넘겨받은
주소의 변수 자체를 함수에서 조작하는 방식을 Call by reference라고 한다.
 
Call by value와 Call by reference 는 각각의 특징이 있는데, Call by value의 경우 
데이터(값)을 복사해서 함수로 전달하기 때문에 원본의 데이터(값)가 변경 될 가능성이 없지만, 
인자를 넘겨줄 때 마다 메모리의 공간을 할당하기 때문에 메모리 공간을 좀 더 잡아먹게 된다. 
Call by reference의 경우 위에서 언급한 메모리 공간 할당의 문제를 벗어나게 되었지만 
대신에 원본의 데이터(값)를 훼손할 수 있다는 문제점이 있다.

### 배열과 연결리스트 (Array & LinkedList)
##### 배열
배열은 데이터를 논리적 순서에 따라 순차적으로 데이터를 입력하며, 물리적 주소 또한 순차적이다. 
그리고 인덱스를 가지고 있어서 원하는 데이터를 한번에 접근이 가능하기 데이터 접근 속도가 매우 빠르다. 
그러나 배열은 데이터의 삽입/삭제에는 취약하다. 배열 특성상 데이터 삽입/삭제가 이루어지면 
삽입/삭제가 이루어진 위치의 다음부터 모든 데이터의 위치를 변경해야 하기 때문이다.

##### 연결리스트
연결리스트는 데이터를 논리적 순서에 따라 데이터를 입력한다. 하지만 물리적 주소는 순차적이지 않다. 
인덱스를 가지고 있는 배열과는 달리 연결리스트는 인덱스 대신 현재 위치의 이전 및 다음 위치를 기억하고 있다. 
때문에 한번에 데이터 접근이 가능하지 않고 연결되어 있는 링크를 따라가야만 접근이 가능하고, 
배열에 비해 속도가 떨어진다. 하지만 데이터 삽입/삭제는 논리적 주소만 바꿔주면 되기 때문에 
데이터 삽입/삭제는 용이하다.

### 가장 빠른 정렬
평균적인 시간 복잡도를 생각해보면 merge sort와 quick sort가 O(nlogn)의 시간 복잡도를 가져
일반적으로 사용되는 정렬 중 가장 빠르다.
merge sort의 경우 최악의 test case에서도 O(nlogn)의 시간복잡도를 가지지만 
quick sort는 worst case에서 O(n^2)의 시간복잡도를 가진다.

##### Quick Sort
Pivot을 정한 뒤 Pivot을 제외한 나머지 원소들을 Pivot과 크기를 비교해 Pivot보다
작은 원소들은 Pivot 앞에 위치하게 하고 나머지는 Pivot뒤에 위치하게 한다.
모든 원소에 대한 크기 비교가 끝나면 Pivot을 맞는 자리에 위치하게 하고
Pivot 앞과 Pivot뒤의 부분 배열에 대해 재귀적으로 Quick Sort를 호출한다.
모든 원소에 대하여 크기 비교가 될 때까지 반복적으로 실행하여 배열을 완료한다.

##### Merge Sort
배열을 반으로 나눈 뒤 반으로 나뉘어진 두 배열의 원소끼리 크기비교를 통해 순서대로
새로운 배열에 위치시키는 방식으로 정렬을 완료시킨다.
크기비교 전에 재귀적으로 반으로 나눈 부분에 대해 각각 Merge sort를 호출하여
반으로 나뉜 부분들이 크기 비교되기 전에 미리 정렬이 되도록 한다.
결과적으로 가장 작은 부분부터 정렬이 진행되고 정렬이 완료된 부분이 또 다시 더 큰
부분과 정렬이 진행되는 방식으로 Bottom-Top 구조로 정렬이 진행된다.
Quick Sort는 전체가 정렬되고 각각의 부분 집합에서 나머지 정렬이 진행되는 Top-Bottom
구조를 가지므로 서로 다른 방법으로 정렬이 진행된다.
Merge Sort는 Worst Case에서도 O(nlogn)의 시간복잡도를 가지지만 정렬을 진행할 때
배열의 크기만큼 같은 크기의 메모리를 할당해야 하므로 Quick Sort에 비해 더 큰
메모리를 필요로 한다.

### Resful
REST(Representational State Transfer)는 월드 와이드 웹과 같은 분산 하이퍼미디어 
시스템을 위한 소프트웨어 아키텍처의 한 형식이다.
요즘은 웹 설계를 할 때 가장 일반적으로 사용되는 방법 중 하나다.
REST 원리를 따르는 시스템은 종종 RESTful이란 용어로 지칭된다.
하나의 서버로 여러대의 클라이언트를 대응하도록 할때 필요한것이 RESTFul API이다.
자세한 설명은 http://blog.remotty.com/blog/2014/01/28/lets-study-rest/ 를 참조한다

### ascii-code
아스키 코드는 미국에서 표준화한 정보교환용 7비트 부호체계이다. 000(0x00)부터 
127(0x7F)까지 총 128개의 부호가 사용된다. 이는 영문 키보드로 입력할 수 있는 모든 
기호들이 할당되어 있는 부호 체계이며, 매우 단순하고 간단하기 때문에 어느 시스템에서도
적용가능하다는 장점이 있으나, 2바이트 이상의 코드를 표현할 수 없기 때문에 국제표준의 
위상은 유니코드에게 넘어갔다.
8비트중 7비트만 사용된 이유는 나머지 1비트는 parity bit로 에러를 검출하기 위해 사용된다,

### Bash
배시 (Bash, Bourne-again shell, 본 어게인 셸)은 본 셸을 대체하는 자유 소프트웨어로서 
GNU 프로젝트를 위해 브라이언 폭스(Brian Fox)가 작성한 유닉스 셸이다.

### GCC
GNU 컴파일러 모음(GNU Compiler Collection, 줄여서 GCC)는 GNU 프로젝트의 일환으로 개발되어 
널리 쓰이고 있는 컴파일러이다.
자유 소프트웨어 중에 가장 잘 알려진 것들 중 하나인 GCC는 원래 C만을 지원했던 컴파일러로
이름도 "GNU C 컴파일러"였다. 이러한 까닭에 현재에도 GCC는 GNU 컴파일러 모음의 일부인 
GNU C 컴파일러(GNU C Compiler)의 줄임말로 쓰이기도 한다. 그러나 나중에 C++, 자바, 
포트란, 에이다 등 여러 언어를 컴파일할 수 있게 되면서, 현재의 이름으로 바뀌게 되었다.

### Callback 함수
콜백 함수는 파라메터를 통해 다음 실행지점을 지시하는 함수를 전달한다. 함수가 일급 
객체로 취급되는 언어에서는 함수 자체, 그렇지 않은 곳에서는 인터페이스나 함수 포인터를
파라메터로 넘긴다. 콜백 함수를 전달받은 함수는 실행 지점 마지막에 호출자 측으로 반환되는
대신 이 콜백 함수로 다시 한 번 진입한다. 즉 재귀함수와 비슷하게 동작한다.
콜백 함수는 실행에 오랜 시간이 걸리는 함수, 예를 들어 네트워크로부터 데이터를 다운로드받는 
함수 등에서 다운로드 완료시 다음 행동을 지정하는 등의 분야에서 멀티스레드와 함께 사용된다. 
물론 고전적인 리턴 메서드를 써도 동작이 되기는 하지만, 리턴값을 받을 때까지 메인 스레드가 
얼어버린다는 문제점이 있어 보통은 콜백 함수를 사용한다. 멀티스레딩이 불가능한 자바스크립트는 
이 콜백 함수 사용이 필수적이다.
콜백 함수를 사용하는 프로그램은 비동기로 동작할 수 있는데 비동기로 동작하는 함수는 
자신의 작업이 다 끝나지 않았더라도 즉시 호출자 측으로 반환되는 특성이 있다.

### Hash Table
Hash function을 이용하여 key에 value를 mapping하는 구조를 나타내는 Table.

### Semaphore
두 개의 원자적 함수로 조작되는 정수 변수로서, 멀티프로그래밍 환경에서 공유 자원에 대한 
접근을 제한하는 방법으로 사용된다. 이는 철학자들의 만찬 문제의 고전적인 해법이지만 
모든 교착 상태를 해결하지는 못한다.
공유자원이 사용 중인지 확인하고, 공유자원을 사용할 수 있는 상태라면 공유자원을 사용하고
공유자원을 사용할 수 없는 상태로 바꾸고, 공유자원의 사용이 끝났다면 사용 가능한 공유
자원의 수를 1 늘리는 방식으로, 공유자원에 대한 사용을 컨트롤하는데 사용하는 방법

### Message Queue
메시지 큐(message queue)는 사용자가 키보드나 마우스로 명령한 것을 메시지 형태로 변환하여 
저장하는 큐이다. 메시지 큐는 윈도 운영 체제의 모든 스레드에 존재한다. 
사용자가 창에 어떤 명령을 보내면 프로그램(또는 창)이 그 큐에서 메시지를 읽고 처리한다. 
예를 들어, 마우스를 움직이면 마우스를 움직였다(WM_MOUSEMOVE)는 메시지가 메시지 큐에 
저장되고 프로그램은 이에 맞는 처리를 한다. 즉, 메시지 큐는 프로그램(또는 창)에게 사용자가 
취한 행동을 변환, 실행하게 만든다.

### 파이프
파이프(pipe)는 유닉스 계열 운영 체제에서(어느 정도까지는 마이크로소프트 윈도에서) 제공되는 
병행성 메커니즘의 하나로서, 두 프로세스가 생산자-소비자 모델에 따라 통신할 수 있게 해주는 
원형 버퍼이다. 즉, 파이프는 한 프로세스가 쓰고 다른 프로세스가 읽는 선입선출 형태의 큐라 
할 수 있다.
파이프를 이용하여 한 프로세스가 데이터를 입력하면 연결된 다른 프로세서에서는 저장된
데이터를 받을 수 있는 방법으로 파이프를 이용하여 데이터를 주고 받을 수 있다.
파이프에는 일정한 크기의 공간이 할당되어 있다. 어떤 프로세스가 파이프에 데이터를 기록하려고 
할 때 충분한 공간이 남아있다면 기록이 즉시 수행되겠지만, 공간이 부족하다면 그 프로세스는 
차단된다. 이것은 운영체제가 상호배제를 수행한 결과이다. 즉 한 순간에 1개의 프로세스만이 
파이프에 접근할 수 있는 것이다.

### Deadlock
교착 상태(膠着狀態, 영어: deadlock)란 두 개 이상의 작업이 서로 상대방의 작업이 끝나기 만을 
기다리고 있기 때문에 결과적으로 아무것도 완료되지 못하는 상태를 가리킨다. 예를 들어 
하나의 사다리가 있고, 두 명의 사람이 각각 사다리의 위쪽과 아래쪽에 있다고 가정한다. 
이때 아래에 있는 사람은 위로 올라 가려고 하고, 위에 있는 사람은 아래로 내려오려고 한다면, 
두 사람은 서로 상대방이 사다리에서 비켜줄 때까지 하염없이 기다리고 있을 것이고 결과적으로 
아무도 사다리를 내려오거나 올라가지 못하게 되듯이, 전산학에서 교착 상태란 다중 프로그래밍 
환경에서 흔히 발생할 수 있는 문제이다. 
이 문제를 해결하는 일반적인 방법은 아직 없는 상태이다.
다중 프로그래밍 환경에서 프로세스가 서로 맞물려 상대방이 끝나야 자신의 프로세스를 실행할 수
있을 경우 서로 상대방이 끝나기만을 기다려 서로 실행될 수 없다.
이런 상태를 Deadlock이라고 한다.

### IPC(interprocess communication)
프로세스들간의 상호 자료와 정보 교환하는 통신 방법

##### 가. 파이프에 의한 통신
- 프로세스들은 메일 박스와 비슷하게 파이프를 통해서 프로세스간에 통신하는 기법
- 파이프는 각각 읽기 끝(read end)과 쓰기 끝(write end)을 갖음

##### 나. 메시지 교환에 의한 통신(메시지 전달 방식)
- OS는 통신기능을 제공할 책임을 가지며 메시지 교환을 통해 프로세스간 통신을 하며 주로 분산환경에서 사용

##### 다. 공유메모리에 의한 통신
- OS가 공유메모리를 제공하고 통신은 프로그래머가 직접 제어
- 한 시스템 내에서만 가능함
- 프로세스 P1이 전송한 메시지가 공유메모리에 있고 Process P2가 공유메모리의 메시지를 읽음

### Get과 Post방식의 차이
##### Get
- 클라이언트에서 서버로 데이터를 전달할 때, 주소 뒤에 "이름"과 "값"이 결합된 스트링 형태로 전달
- 주소창에 쿼리 스트링이 그대로 보여지기 때문에 보안성이 떨어진다.
- 길이에 제한이 있다.(=전송 데이터의 한계가 있다.)
- Post방식보다 상대적으로 전송 속도가 빠르다.

##### Post
- 일정 크기 이상의 데이터를 보내야 할 때 사용한다.
- 서버로 보내기 전에 인코딩하고, 전송 후 서버에서는 다시 디코딩 작업을 한다.
- 주소창에 전송하는 데이터의 정보가 노출되지 않아 Get방식에 비해 보안성이 높다.
- 속도가 Get방식보다 느리다.
- 쿼리스트링(문자열) 데이터 뿐만 아니라, 라디오 버튼, 텍스트 박스 같은 객체들의 값도 전송가능.

##### Get과 Post의 차이점
- Get은 주로 웹 브라우저가 웹 서버에 데이터를 요청할 때 사용
- Post는 웹 브라우저가 웹 서버에 데이터를 전달하기 위해 사용.
- Get을 사용하면 웹 브라우저에서 웹 서버로 전달되는 데이터가 인코딩되어 URL에 붙는다.
- Post방식은 전달되는 데이터가 보이지 않는다.
- Get방식은 전달되는 데이터가 255개의 문자를 초과하면 문제가 발생할 수 있다.
- 웹서버에 많은 데이터를 전달하기 위해서는 Post 방식을 사용하는 것이 바람직하다.

### Session과 Cookie
##### Session과 Cookie 사용 이유
- 현재 우리가 인터넷에서 사용하고 있는 HTTP프로토콜은 연결 지향적인 성격을 버렸기 때문에 새로운 페이지를 요청할 때마다
 새로운 접속이 이루어지며 이전 페이지와 현재 페이지 간의 관계가 지속되지 않는다. 이에 따라 HTTP프로토콜을 이용하게 되는 
 웹사이트에서는 웹페이지에 특정 방문자가 머무르고 있는 동안에 그 방문자의 상태를 지속시키기 위해 쿠키와 세션을 이용한다.

##### Session
- 특정 웹사이트에서 사용자가 머무르는 기간 또는 한 명의 사용자의 한번의 방문을 의미한다.
- Session에 관련된 데이터는 Server에 저장된다.
- 웹 브라우저의 캐시에 저장되어 브라우저가 닫히거나 서버에서 삭제시 사라진다.
- Cookie에 비해 보안성이 좋다.

##### Cookie
- 사용자 정보를 유지할 수 없다는 HTTP의 한계를 극복할 수 있는 방법
- 인터넷 웹 사이트의 방문 기록을 남겨 사용자와 웹 사이트 사이를 매개해 주는 정보이다.
- Cookie는 인터넷 사용자가 특정 웹서버에 접속할 때, 생성되는 개인 아이디와 비밀번호, 방문한 사이트의 정보를 담은 임시 파일로써,
  Server가 아닌 Client에 텍스트 파일로 저장되어 다음에 해당 웹서버를 찾을 경우 웹서버에서는 그가 누구인지 어떤 정보를 주로 찾았는지 등을 파악할 때 사용된다.
- Cookie는 Client PC에 저장되는 정보기 때문에, 다른 사용자에 의해서 임의로 변경이 가능하다.(정보 유출 가능, Session보다 보안성이 낮은 이유)

Q. 보안성이 낮은 Cookie 대신 Session을 사용하면 되는데 안하는 이유?
A. 모든 정보를 Session에 저장하면 Server의 메모리를 과도하게 사용하게 되어 Server에 무리가 감

### Interface, Abstract
##### Interface
- 일종의 추상 클래스
- 오직 추상메서드와 상수만을 멤버로 갖는다.
- Implements 키워드를 사용
- 상속의 관계가 없는 클래스간 서로 공통되는 로직을 구현하여 쓸 수 있도록한다.
- Extends는 하나의 클래스만 상속 가능하나 Interface는 다중 상속이 가능하다.
##### Abstract
- 추상메서드를 하나 이상 가진 클래스
- 자신의 생성자로 객체 생성 불가능
- 하위 클래스를 참조하여 상위 클래스의 객체를 생성
- 하위 클래스를 제어하기 위해 사용
#### Interface vs Abstract
###### 공통점 
- new 연산자로 인스턴스 생성 불가능.
- 프로토타입만 있는 메서드를 갖는다.
- 사용하기 위해서는 하위클래스에서 확장/구현 해야 한다.
###### 차이점
- 사용하는 키워드가 다르다.
- Abstract는 일반 메서드를 사용할 수 있지만, Interface는 메서드 선언만 가능하다.

### 파이썬에서의 다중상속과 staticmethod, classmethod 구분
##### 다중상속
파이썬은 다중상속이 가능하다
    
    class A():
    	def m(self, *args, **kwargs):
    		print '%s.m(%s,%s)' % (self.__class__.__name__, args, kwargs)
    	def mA(self, *args, **kwargs):
    		print '%s.mA(%s,%s)' % (self.__class__.__name__, args, kwargs)
    class B():
    	def m(self, *args, **kwargs):
    		print '%s.m(%s,%s)' % (self.__class__.__name__, args, kwargs)
    	def mB(self, *args, **kwargs):
    		print '%s.mB(%s,%s)' % (self.__class__.__name__, args, kwargs)
    class C(A,B):
    	def m(self, *args, **kwargs):
    		print '%s.m(%s,%s)' % (self.__class__.__name__, args, kwargs)
C 클래스는 A와 C 모두에서 상속을 받았고, m 메소드는 오버로딩 되어 있다. 
(파이썬에서는 그냥 namespace 개념으로 해당 공간의 dict를 덮어쓰고 참조하는 식으로 되어 있다)

##### staticmethod, classmethod 비교

    class A():
    	S_VAL=1
    	def m(self, *args, **kwargs):
    		print '%s.m(%s,%s)' % (self.__class__.__name__, args, kwargs)
    	def mA(self, *args, **kwargs):
    		print '%s.mA(%s,%s)' % (self.__class__.__name__, args, kwargs)
    	@staticmethod
    	def s():
    		print '%s.c: S_VAL=%s' % (A.__name__, A.S_VAL)
    	@classmethod
    	def c(cls):
    		print '%s.c: S_VAL=%s' % (cls.__name__, cls.S_VAL)
    class B():
    	S_VAL=2
    	def m(self, *args, **kwargs):
    		print '%s.m(%s,%s)' % (self.__class__.__name__, args, kwargs)
    	def mB(self, *args, **kwargs):
    		print '%s.mB(%s,%s)' % (self.__class__.__name__, args, kwargs)
    class C(A,B):
    	S_VAL=3
    	def m(self, *args, **kwargs):
    		print '%s.m(%s,%s)' % (self.__class__.__name__, args, kwargs)
staticmethod는 첫번째 인자가 self로 시작하는 일반 메소드와는 달리 self로 시작하지 않는다.
위의 코드에서는 내용으로 클래스에 정의되어 있는 S_VAL을 출력한다.
따라서, 

A.s()
C.s()

라고 호출하면,

A.c: S_VAL=1
A.c: S_VAL=1

라고 동일 결과가 나온다.

상속은 받았지만 실질적으로 동일 함수가 수행된다.

classmethod는 @classmethod 라는 데코레이터를 이용하고, 첫번째 인자로는 cls를 받는다.
그리고 내용으로는 클래스에 정의되어 있는 S_VAL을 출력합니다.

A.c()
C.c()

라고 호출하면,

A.c: S_VAL=1
C.c: S_VAL=3

라는 결과가 잘 나온다.

즉 상속한 클래스의 클래스 내용에 따라 작업을 하고 싶으면 @classmethod를 이용하고,
method 정의된 클래스의 내용에 따라 작업을 하고 싶다면 @staticmethod를 호출하면 된다

### Framework
프레임워크는 특정 형태의 소프트웨어 문제를 해결하기 위해 상호 협력하는 클래스프레임과 인터페이스 프레임의 집합
특정한 틀을 만들어놓고 거기에 살을 붙여 놓음으로써 프로그램을 만들어 작업시간을 줄여준다.
프레임워크가 중요한 이유는 객체지향 개발을 하게 되면서 개발자의 취향에 따라 다양한 프로그램이 나오게 되었다.
프로그램 개발에 투입되는 개발자도 점점 늘어남에 따라 전체 시스템의 통합성, 일관성이 부족하게 되었기 때문이다. 
그래서 개발자의 자유를 제한하기 위해 프레임워크를 도입했다.

##### 프레임워크가 가져야할 특징
- 개발자들이 따라야할 가이드라인을 가진다.
- 개발할 수 있는 범위가 정해져 있다.
- 개발자를 위한 다양한 도구들이 지원된다.

##### 프레임워크의 장/단점
- 장점 : 개발 시간을 줄일 수 있고 오류로부터 자유로울 수 있다.
- 단점 : 프레임워크에 너무 의존하면 개발 능력이 떨어져서 프레임워크 없이 개발하는 것이 불가능해지는 점이다.

### Garbage Collection(가비지 컬렉션)
시스템에서 더이상 사용하지 않는 동적 할당된 메로리 블럭을 찾아 자동으로 다시 사용 가능한 자원으로 회수하는 것으로 
시스템에서 가비지컬렉션을 수행하는 부분을 가비지 컬렉터라 부른다.

### Primitive type과 Reference type
##### Primitive type - 변수에 값 자체를 저장 
- 정수형 byte, short, int, long
- 실수형 float, double
- 문자형 char
- 논리형 boolean
##### Reference type - 메모리상에 객체가 있는 위치를 저장
- 종류 : Class, Interface, Array 등

### Thread와 Process
##### Thread(쓰레드) - 프로세스내에서 동시에 실행되는 독립적인 실행 단위를 말함, 장점으로는 자원을 많이 사용하지 않고 구현이 쉬우며 범용성이 높다
##### Process(프로세스) - 운영체제에서 실행중인 하나의 프로그램(하나 이상의 쓰레드를 포함한다.)
##### Thread 장점
- 빠른 프로세스 생성
- 적은 메모리 사용
- 쉬운 정보 공유
##### Thread 단점
- 교착상태에 빠질 수 있다.
##### * 교착상태 - 다중프로그래밍 체제에서 하나 또는 그 이상의 프로세스가 수행 할 수 없는 어떤 특정시간을 기다리고 있는 상태.
##### Thread와 Process 차이
여러 분야에서 '과정' 또는 '처리'라는 뜻으로 사용되는 용어로 컴퓨터 분야에서는 '실행중인 프로그램'이라는 뜻으로 쓰인다. 
이 프로세스 내에서 실행되는 각각의 일을 스레드라고 한다. 프로세스 내에서 실행되는 세부 작업 단위로 여러 개의 스레드가 하나의 프로세스를 이루게 되는 것이다.

### 소켓 통신(TCP/UDP)
##### TCP(Transmission Control Protocol)
- 연결형 서비스 제공
- 높은 신뢰성 보장
- 연결의 설정(3-way handshaking)
- 연결의 해제(4-way handshaking)
- 데이터 흐름 제어, 혼잡 제어
- 전이중, 점대점 서비스(양방향 송수신 서비스)
##### UDP(User Datagram Protocol)
- 비연결형 서비스 제공
- 신뢰성이 낮음
- 데이터의 전송 순서가 바뀔 수 있음
- 데이터 수신 여부 확인 안함(3-way handshaking과 같은 과정 X)
- TCP보다 전송속도가 빠름

### Singleton Design Patter(싱글톤 디자인 패턴, 싱글톤 패턴)
클래스 인스턴스가 하나만 만들어지도록 하고, 그 인스턴스에 대한 전역 접근을 제공한다.

### OSI 7 Layer
국제표준화기구(ISO)에서 개발한 모델로, 컴퓨터 네트워크 프로토콜 디자인과 통신을
7개의 계층으로 나누어 설명한 모델을 말한다






