#Algorithm

##Algorithm 이론들과 푸는 과정에서의 C,C++ 내용들

###C++의 stack
C++에서 stack은 #include <stack>을 한다면 C++에서 제공하는 기본 stack을 사용할 수 있고
stack<int> a; 의 형태처럼 데이터 타입을 정해서 해당 stack을 선언해 해당 data type의 stack을 만들 수 있다.
stack.push(123) 처럼 parameter로 push할 데이터를 넣고 stack에 push해줄수 있으며 stack.top()은 현재 stack의 top에 있는 data를 확인할 수 있다.
top은 stack에서 data를 제거하지는 않으며 그냥 top에 있는 data가 무엇인지만 받아온다.
stack.pop()을 통해서 stack의 top에 있는 data를 제거할 수 있는데 pop의 return type은 void이므로 단순히 pop을 통해 변수에 데이터를 입력 해 줄수는 없다.
변수에 스택에서 pop한 결과를 선언하기 위해서는 int a=stack.top(); stack.pop() 처럼 top에 있는 data를 받아오고 pop을 통해 제거하는 형태로 변수에
값을 주고 pop을 통해 stack의 top에 있는 data를 제거해주면 된다.


###C나 C++의 Sort, 람다함수, 객체함수

####Sort
기본적으로 제공하는 Sort 함수는 Sort 되는 조건을 지정해 Sort 해줄 수 있다.
default로 조건이 오름차순으로 되있으며 조건을 바꿔서 Sort 되는 방법을 다르게 해줄 수 있다.
예를 들어
    
    bool cmp(int a,int b) {return a<b;}
    
    sort(a.begin(), a.end(), cmp)     
처럼 sort 함수에 조건을 우리가 만든 조건을 넣어서 sort함수를 사용하면 
Sort가 기본인 sort를 할 때 앞 뒤 비교할 때 a<b 이면 true 를 return 하고, 아니면 false를 return 해 비교 되는 조건을 주는것이다.
 
    
####람다함수
overhead가 가장 적게 사용하기 위해서는 람다함수를 사용할 수 있는데
    
    sort(a.begin(), a.end(), 
    [](const point& a, const point& b)
    {
        return a.x > b.x
    }
    
처럼 주면 재사용이 되지 않는 해당 부분에서만 사용되는 이름없는 람다함수를 넣어주는것이다.
해당 조건에만 마지막 조건으로 입력되있는 함수를 사용해 비교조건을 이용하고 다른 부분에서는 다시 가져다가 사용할 수는 없다.
람다함수를 사용하면 overhead가 가장적게 일어난다.
저기서 파라미터로 const point& a 의 형태로 되어 있는데 이건 포인터로 해당 함수를 가르켜 다시 참조하는것이 아니라 해당 변수가 선언된 부분을 직접 가르켜
직접 참조하는것이다. 시스템 프로그래밍에서 배우는 immediate addressing을 생각하면 된다.


####객체함수
각 객체를 선언할 때 객체안에 그 객체의 이름으로 사용할 수 있는 함수를 선언 해줄 수도 있다.
C++에서는 struct가 객체의 클래스로 사용 되는데 그 안에 inline operator()를 선언해 해당 객체의 이름으로 함수를 사용할 수 있다.

    template<typename T>
    struct less
    {
        int 
        inline bool operator()(const T& a, const T& b)
        {
            retirn a > b;
        }
    }
    
처럼 struct 안에 operator() 를 이용해 함수를 선언해주면 함수를 less() 처럼 사용할 수 있다.
template로 type을 저렇게 선언해주면 데이터타입으로 어떤것이 들어와도 비교할 수 있다.
예를 들어 위의 코드처럼 template으로 T를 선언해주고 a앞에 T라고 데이터타입이 있으면 어떠한 데이터 타입이 들어올 수 있고
어떠한 타입의 값이든 입력 받아 값을 비교해서 결과를 bool 값으로 return 해준다.


###그래프 & 트리
그래프는 배열이나 리스트로 나타낼 수 있다.
C++에서는 리스트 대신에 vector를 사용하는데 그 이유는 리스트의 값들은 메모리 내에서 연속된 주소를 가지지 않아서 캐쉬의 hit ratio(적중률)이 떨어져 속도가 더 느리다.
벡터는 메모리 내에서 연속된 주소를 가지므로 더 높은 hit ratio를 가지므로 속도가 더 빠르므로 보통 벡터를 사용한다.


### &
함수의 파라미터로 자신이 원하는 주소의 값을 넘겨 해당 주소에 있는 값을 계산하고 싶다면 해당 주소와 해당 주소에 있는 값을 모두 넘겨야 한다
이럴 때 파라미터로 &을 포함해서 넘기면 해당 주소에 있는 값을 파라미터로 넘기고 결과로 그 주소에 있는 값을 변경할 수 있다.

    void swap(profile& first, profile& second)
    {
        profile temp;
        temp = first;
        first = second;
        second = temp;
    }
이런식으로 &을 포함해서 값을 넘기면 해당 주소에 대한 해당 값이 파라미터로 넘어가 값이 변경될 수 있다.

###BFS
문제의 상태가 정점으로 나타내진다.
점과 점사이의 거리가 1일때 최소거리를 구한다.
목적:모든 정점을 1번씩 방문

#####BFS 조건
1.최소비용을 찾는 문제
2.상태=정점
3.점과 점사이의 가중치가 1

#####문제의 제한
정점개수의 제한
최대 정점개수로 시간복잡도를 계산해 시간을 예측한다.
1억번정도의 연산에 1초정도의 시간이 걸린다.

#####Queue
BFS는 큐를 사용한다.
1.시작점을 큐에 넣는다.
2.반복문을 통해 갈 수 있는 점들을 넣고 시작점을 큐에서 pop 한다
3.반복문을 통해 모든 점을 방문할때까지 반복한다.

특정 정점을 방문했는지 확인 할 check 배열과
해당 정점을 몇번만에 방문했는지 기록할 dist 배열
2개의 배열이 필요하다.

최소값 문제의 핵심은 같은 점을 두 번 방문하지 않는 것.


###다이나믹 프로그래밍
다이나믹 프로그래밍은 큰 문제를 작은 문제로 나눠서 푸는것.
연산을 통해 하나의 data에 대해 연산을 하고 나머지에 대해 또 같은 연산을
진행하는 식의 방법으로 문제를 푼다.
상태가 점화식으로 정의된다

문제에서 경우의 수를 구하라고 하면 대부분 다이나믹 프로그래밍.
확률이나 기대값도 다이나믹 프로그래밍으로 풀 수 있다.
대부분의 다이나믹프로그래밍은 최솟값,최댓값,경우의 수 구하기

#####DP 조건
1.작은 문제 겹침
2.문제의 정답을 작은 문제에서 구한다

다이나믹 프로그래밍은 점화식을 세워야 한다.
점화식의 정의:문제에서 구하라고 하는 것을 1문장으로 나타내는 것.
점화식:수식

ex)
D[N]=N번째 피보나치 수 - 점화식의 정의
D[N]=D[N-1]+D[N-2] - 점화식

#####식 만들기
1.재귀함수 - Top-Down
2.for - Bottom-up
쉬운 문제들은 2가지 방법 둘 다 풀 수 있으므로 편한 걸로 하면 된다.
삼성 SW 시험은 for 문을 쓰는 것이 나을 것 같다

#####Memoization
다이나믹 프로그래밍의 핵심은 Memoization.
하나의 문제를 한 번만 푸는 것을 의미.
같은 문제를 여러 번 풀지 않는다.

###알고리즘 풀이 과정
1.이 문제가 무슨 알고리즘인지 인식
2.정의
3.식
4.코딩
문제를 풀 때 입력을 먼저 읽고 시간 복잡도가 어떤 경우일 때 시간제한안에
풀 수 있는지 확인한다.


###DFS
존재하는 모든 경로를 다 해보고 그 중 최솟값을 구하는 것
전체 경우의 수가 몇 가지가 되는지 알아야 한다.
상태가 함수로 정의된다.
DFS를 잘 풀기 위해서는 재귀 함수를 잘 만들어야 한다.
두 가지 시간 복잡도
    n! : 순서가 중요
    2^n : 순서가 중요하지 않음, 부분집합 문제
    
부분집합 문제는 비트마스크를 이용하면 재귀함수를 스지 않고도 풀 수 있다.

공집합 : 0
전체집합 : 2^n -1 - for문을 통해 전체 경우의 수를 확인할 수 있다

#####함수
1.정답을 찾은 경우
2.불가능한 경우
3.다음 경우 호출

dfs(){
    1의 경우
    2의 경우
    3의 경우
}
형태로 정의된다.

